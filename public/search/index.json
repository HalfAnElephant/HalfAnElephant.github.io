[{"content":"Codeforces Round 1056 (Div. 2) D. Batteries 题目链接: Codeforces Round 1056 (Div. 2) D. Batteries\n题目简述 题目大意 在有限的尝试次数内，通过将电池配对测试手电筒来找到两个工作电池，同时面对一个会动态改变电池好坏状态的裁判器。\n数据范围 $1\\leq t\\leq 50$\n$2\\leq n\\leq 40$\n$\\Sigma n \\leq 200$\n每个样例尝试次数 $\\leq \\lfloor \\frac{n^2}{a}\\rfloor$\n题目思路 关键在于会动态调整的交互器，即若采取较差策略，消耗过多测试机会的话，那么将会动态调整后续安排，将电池安排到策略未包含的地方。\n因此我们采取先小块后大块的策略，先查询长度为2的块内部所有对，然后以此为3、4……\n赛后 ","date":"2025-10-06T18:18:00+08:00","image":"https://halfanelephant.github.io/p/codeforces-round-1056-div.-2-d.-batteries/cover_hu_a2aaf39a3dd1902.png","permalink":"https://halfanelephant.github.io/p/codeforces-round-1056-div.-2-d.-batteries/","title":"Codeforces Round 1056 (Div. 2) D. Batteries"},{"content":"Codeforces Round 1056 (Div. 2) C. The Ancient Wizards\u0026rsquo; Capes 题目链接: Codeforces Round 1056 (Div. 2) C. The Ancient Wizards\u0026rsquo; Capes\n题目简述 题目大意 给定一个整数 $n$，以及一个长度为 $n$ 的数组 $a$。$a_i$ 表示在位置 $i$ 处可见的巫师数量。 一个巫师 $j$ 在位置 $i$ 处可见的条件是：\n巫师 $j$ 将斗篷穿在左侧，且 $i \\geq j$。 巫师 $j$ 将斗篷穿在右侧，且 $i \\leq j$。\n巫师 $i$ 在位置 $i$ 处始终可见。 你的任务是计算与数组 $a$ 一致的斗篷排列方式的数量，结果对 676767677 取模。\n数据范围 $1\\leq n\\leq 10^5$\n$1\\leq t \\leq 10^4$\n$1\\leq a_i \\leq n$\n$\\Sigma n \\leq 10^5$\n题目思路 通过寻找递推关系来简化问题。\n我们定义 $d_j$ 表示斗篷朝向，若第 $j$ 个巫师斗篷方向朝右则为 $0$，反之则为 $1$。\n由此可得 $a_i$ 表达式:\n$$ a_i = \\Sigma_{j=1}^i d_j + \\Sigma_{j=i}^n(1-d_j) $$相邻项做差可得：\n$$ a_i - a_{i-1} = d_i + d_{i - 1} - 1 $$变形得到：\n$$ d_i = (a_i-a_{i - 1} + 1) - d_{i-1} $$由此可知，$d_i$仅由$d_{i-1}$以及$a_i$、$a_{i - 1}$决定。所以可以假定$d_1$进行检验。此时，我们仅需要检查两种可能，即$d_1$为$0$或$1$.进行假设后进行递推，判断$d_i$是否合法。\n赛后 tourist\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 for (int r = 0; r \u0026lt; 2; r++) { vector\u0026lt;int\u0026gt; b(n); b[0] = r; for (int i = 1; i \u0026lt; n; i++) { b[i] = 1 - (b[i - 1] + a[i] - a[i - 1]); } int mn = *min_element(b.begin(), b.end()); int mx = *max_element(b.begin(), b.end()); if (0 \u0026lt;= mn \u0026amp;\u0026amp; mx \u0026lt;= 1) { int cnt = 1 + accumulate(b.begin() + 1, b.end(), 0); if (cnt == a[0]) { ans += 1; } } 使用 STL 简化代码。\n","date":"2025-10-06T17:08:23+08:00","image":"https://halfanelephant.github.io/p/codeforces-round-1056-div.-2-c.-the-ancient-wizards-capes/cover_hu_a2aaf39a3dd1902.png","permalink":"https://halfanelephant.github.io/p/codeforces-round-1056-div.-2-c.-the-ancient-wizards-capes/","title":"Codeforces Round 1056 (Div. 2) C. The Ancient Wizards' Capes"},{"content":"Codeforces Round 1056 (Div. 2) B. Abraham\u0026rsquo;s Great Escape 题目链接: Codeforces Round 1056 (Div. 2) B. Abraham\u0026rsquo;s Great Escape\n题目简述 题目大意 在 $n\\times n$ 的迷宫中设计箭头的方向，使得恰好有 $k$ 个格子是“可逃脱的起始点”。\n数据范围 $1\\leq t\\leq 1000$\n$2\\leq n \\leq 100,\\ 1 \\leq k \\leq n^2,\\ \\Sigma n^2 \\leq 10^5$\n题目思路 首先判断无法设计的情况。从样例中可以才测出，当且仅当 k == n * n - 1 时迷宫无法被设计，其余所有情况均可设计。\n然后构思如何设计。总体思路为，先将所有格子中的方向设为统一方向，即所有格子均为可逃脱的起始点，然后再填入一定数量的无法逃出的方向，以使迷宫满足题意。\n赛事思路主要是构造两两冲突，即[R][L]之类，以此填充迷宫。剩下如果不够则用上下的[U]和[D]来构造。此方法构造理论上可行，但实际编写时细节较难处理，多次提交均错误。\n赛后 赛后观察其他选手代码，发现思路基本接近。例如tourist的代码，先提充最顶层，使得最顶层无法逃出，接下来仅需向下填充网格，若填充[U]则无法逃出，若填充[D]则可以逃出。具体代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (k \u0026gt; 0) { k -= 1; if (i == 0 \u0026amp;\u0026amp; j == 0) cout \u0026lt;\u0026lt; \u0026#39;R\u0026#39;; else if (i == 0) cout \u0026lt;\u0026lt; \u0026#39;L\u0026#39;; else cout \u0026lt;\u0026lt; \u0026#39;U\u0026#39;; } else { cout \u0026lt;\u0026lt; \u0026#39;D\u0026#39;; } } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 代码中比较巧妙的是，未使用额外的数组来储存信息，直接按照逻辑输出迷宫，便于节省空间和时间消耗。\n","date":"2025-10-06T12:53:51+08:00","image":"https://halfanelephant.github.io/p/codeforces-round-1056-div.-2-b.-abrahams-great-escape/cover_hu_a2aaf39a3dd1902.png","permalink":"https://halfanelephant.github.io/p/codeforces-round-1056-div.-2-b.-abrahams-great-escape/","title":"Codeforces Round 1056 (Div. 2) B. Abraham's Great Escape"},{"content":"珂朵莉树 适用于区间复制、拆分、查找和自定义操作\n时间复杂度： set实现：$O\\left(nloglog_2n\\right)$ 链表实现：$O\\left(n log_2n\\right)$ mutable 的作用： mutable 的意思是“可变的”，让我们可以在后面的操作中修改 v 的值。在 C++ 中，mutable 是为了突破 const 的限制而设置的。被 mutable 修饰的变量（mutable 只能用于修饰类中的非静态数据成员），将永远处于可变的状态，即使在一个 const 函数中。\n这意味着，我们可以直接修改已经插入 set 的元素的 v 值，而不用将该元素取出后重新加入 set。\n实现： 节点保存： 1 2 3 4 5 6 7 8 9 struct Node_t { int l, r; mutable int v; Node_t(const int \u0026amp;il, const int \u0026amp;ir, const int \u0026amp;iv) : l(il), r(ir), v(iv) {} inline bool operator\u0026lt;(const Node_t \u0026amp;o) const { return l \u0026lt; 0.l; } }; set\u0026lt;Node_t\u0026gt; odt; 其中，v 是附加数据。\n分裂区间： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 set\u0026lt;Node_t\u0026gt;::iterator split(int x) { if (x \u0026gt; n) { return odt.end(); } auto it = --odt.upper_bound((Node_t){x, 0, 0}); if (it-\u0026gt;l == x) { return it; } int l = it-\u0026gt;l; int r = it-\u0026gt;r; int v = it-\u0026gt;v; odt.erase(it); odt.insert(Node_t(l, x - 1, v)); return odt.insert(Node_t(x, r, v)).first; } 将包含点x的区间(设为[l, r]),分裂为两个区间[l, r)和[x, r],返回指向后者的迭代器。\n任何对于==[l, r]==的区间操作，都可以转换成set上对==$[split(l),split(r+1)]$==的操作。\n区间赋值： 1 2 3 4 5 6 void assign(int l, int r, int v) { auto itr = split(r + 1), itl = split(l); odt.erase(itl, itr); odt.insert(Node_t(l, r, v)); } 其余操作套模板： 1 2 3 4 5 6 7 8 void performance(int l, int r) { auto itr = split(r + 1), itl = split(l); for (; itl != itr; ++itl) { // Perform Operations here } } ","date":"2022-08-07T18:02:25+08:00","image":"https://halfanelephant.github.io/p/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91/cover_hu_4e4ba8074f91c0cb.jpg","permalink":"https://halfanelephant.github.io/p/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91/","title":"珂朵莉树"}]